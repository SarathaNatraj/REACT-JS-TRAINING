"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParameterInspector = exports.LogParameterInspector = void 0;
require("reflect-metadata");
const util = require("util");
function LogParameterInspector(target, propertyKey, parameterIndex) {
    console.log(`LogParameterInspector ${target} ${String(propertyKey)} ${parameterIndex}`);
    console.log(ParameterInspector(target, propertyKey, parameterIndex));
}
exports.LogParameterInspector = LogParameterInspector;
function ParameterInspector(target, propertyKey, parameterIndex) {
    const ret = {
        target, propertyKey, parameterIndex,
        ownKeys: Object.getOwnPropertyNames(target),
        members: {},
        design: {
            type: Reflect.getMetadata("design:type", target, propertyKey),
            paramtypes: Reflect.getMetadata("design:paramtypes", target, propertyKey),
            returntype: Reflect.getMetadata("design:returntype", target, propertyKey)
        }
    };
    for (const key of Object.getOwnPropertyNames(target)) {
        console.log(`ParameterInspector target ${target} key ${key}`);
        try {
            ret.members[key] = {
                obj: target[key],
                descriptor: util.inspect(Object.getOwnPropertyDescriptor(target, key))
            };
        }
        catch (e) {
            ret.members[key] = {
                error: `ParameterInspector could not get data for ${key}`,
                message: e.message
            };
        }
        /* if (typeof target[key] === 'function') {
            ret.members[key] = functionData(target[key]);
        } else {
            ret.members[key] = target[key];
        } */
    }
    return ret;
}
exports.ParameterInspector = ParameterInspector;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFyYW1ldGVySW5zcGVjdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vbGliL1BhcmFtZXRlckluc3BlY3Rvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw0QkFBMEI7QUFDMUIsNkJBQTZCO0FBRzdCLFNBQWdCLHFCQUFxQixDQUFDLE1BQWMsRUFDaEQsV0FBNEIsRUFDNUIsY0FBc0I7SUFFdEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyx5QkFBeUIsTUFBTSxJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxjQUFjLEVBQUUsQ0FBQyxDQUFDO0lBQ3hGLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsTUFBTSxFQUFFLFdBQVcsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO0FBQ3pFLENBQUM7QUFORCxzREFNQztBQUVELFNBQWdCLGtCQUFrQixDQUFDLE1BQWMsRUFDekMsV0FBNEIsRUFDNUIsY0FBc0I7SUFFMUIsTUFBTSxHQUFHLEdBQUc7UUFDUixNQUFNLEVBQUUsV0FBVyxFQUFFLGNBQWM7UUFDbkMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUM7UUFDM0MsT0FBTyxFQUFFLEVBQUU7UUFDWCxNQUFNLEVBQUU7WUFDSixJQUFJLEVBQ0EsT0FBTyxDQUFDLFdBQVcsQ0FBQyxhQUFhLEVBQ3JCLE1BQU0sRUFBRSxXQUFXLENBQUM7WUFDcEMsVUFBVSxFQUNOLE9BQU8sQ0FBQyxXQUFXLENBQUMsbUJBQW1CLEVBQzNCLE1BQU0sRUFBRSxXQUFXLENBQUM7WUFDcEMsVUFBVSxFQUNOLE9BQU8sQ0FBQyxXQUFXLENBQUMsbUJBQW1CLEVBQzNCLE1BQU0sRUFBRSxXQUFXLENBQUM7U0FDdkM7S0FDSixDQUFDO0lBQ0YsS0FBSyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDbEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyw2QkFBNkIsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDOUQsSUFBSTtZQUNBLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUc7Z0JBQ2YsR0FBRyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUM7Z0JBQ2hCLFVBQVUsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7YUFDekUsQ0FBQztTQUNMO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDUixHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHO2dCQUNmLEtBQUssRUFBRSw2Q0FBNkMsR0FBRyxFQUFFO2dCQUN6RCxPQUFPLEVBQUUsQ0FBQyxDQUFDLE9BQU87YUFDckIsQ0FBQTtTQUNKO1FBQ0Q7Ozs7WUFJSTtLQUNQO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFFZixDQUFDO0FBekNELGdEQXlDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAncmVmbGVjdC1tZXRhZGF0YSc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgZnVuY3Rpb25EYXRhIH0gZnJvbSAnLi9VdGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBMb2dQYXJhbWV0ZXJJbnNwZWN0b3IodGFyZ2V0OiBPYmplY3QsXG4gICAgcHJvcGVydHlLZXk6IHN0cmluZyB8IHN5bWJvbCxcbiAgICBwYXJhbWV0ZXJJbmRleDogbnVtYmVyKSB7XG5cbiAgICBjb25zb2xlLmxvZyhgTG9nUGFyYW1ldGVySW5zcGVjdG9yICR7dGFyZ2V0fSAke1N0cmluZyhwcm9wZXJ0eUtleSl9ICR7cGFyYW1ldGVySW5kZXh9YCk7XG4gICAgY29uc29sZS5sb2coUGFyYW1ldGVySW5zcGVjdG9yKHRhcmdldCwgcHJvcGVydHlLZXksIHBhcmFtZXRlckluZGV4KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQYXJhbWV0ZXJJbnNwZWN0b3IodGFyZ2V0OiBPYmplY3QsXG4gICAgICAgIHByb3BlcnR5S2V5OiBzdHJpbmcgfCBzeW1ib2wsXG4gICAgICAgIHBhcmFtZXRlckluZGV4OiBudW1iZXIpIHtcblxuICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgcGFyYW1ldGVySW5kZXgsXG4gICAgICAgIG93bktleXM6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCksXG4gICAgICAgIG1lbWJlcnM6IHt9LFxuICAgICAgICBkZXNpZ246IHtcbiAgICAgICAgICAgIHR5cGU6IFxuICAgICAgICAgICAgICAgIFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCwgcHJvcGVydHlLZXkpLFxuICAgICAgICAgICAgcGFyYW10eXBlczpcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmdldE1ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQsIHByb3BlcnR5S2V5KSxcbiAgICAgICAgICAgIHJldHVybnR5cGU6XG4gICAgICAgICAgICAgICAgUmVmbGVjdC5nZXRNZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LCBwcm9wZXJ0eUtleSlcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgUGFyYW1ldGVySW5zcGVjdG9yIHRhcmdldCAke3RhcmdldH0ga2V5ICR7a2V5fWApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0Lm1lbWJlcnNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBvYmo6IHRhcmdldFtrZXldLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3I6IHV0aWwuaW5zcGVjdChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldC5tZW1iZXJzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGBQYXJhbWV0ZXJJbnNwZWN0b3IgY291bGQgbm90IGdldCBkYXRhIGZvciAke2tleX1gLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldC5tZW1iZXJzW2tleV0gPSBmdW5jdGlvbkRhdGEodGFyZ2V0W2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0Lm1lbWJlcnNba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgICB9ICovXG4gICAgfVxuICAgIHJldHVybiByZXQ7XG5cbn1cbiJdfQ==